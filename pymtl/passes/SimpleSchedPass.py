from __future__ import absolute_import

from collections import deque

from graphviz import Digraph

from pymtl.dsl.errors import UpblkCyclicError

from .BasePass import BasePass, PassMetadata
from .errors import PassOrderError

# =========================================================================
# SimpleSchedPass.py
# =========================================================================
# Generate a simple schedule (no Mamba techniques here) based on the
# DAG generated by some previous pass.
#
# Author : Shunning Jiang
# Date   : Dec 26, 2018



class SimpleSchedPass(BasePass):
    def __call__(self, top):
        if not hasattr(top._dag, "all_constraints"):
            raise PassOrderError("all_constraints")

        top._sched = PassMetadata()

        top._sched.schedule = self.schedule(top)

    def schedule(self, top):

        # Construct the graph

        V = top.get_all_update_blocks() | top._dag.genblks
        E = top._dag.all_constraints
        Es = {v: [] for v in V}
        InD = {v: 0 for v in V}

        for (u, v) in E:  # u -> v
            InD[v] += 1
            Es[u].append(v)

        # Perform topological sort for a serial schedule.

        schedule = []

        Q = deque([v for v in V if not InD[v]])

        while Q:
            u = Q.pop()
            schedule.append(u)
            for v in Es[u]:
                InD[v] -= 1
                if not InD[v]:
                    Q.append(v)

        check_schedule(top, schedule, V, E, InD)

        return schedule


def check_schedule(top, schedule, V, E, in_degree):

    assert schedule

    if len(schedule) != len(V):
        from graphviz import Digraph

        dot = Digraph()
        dot.graph_attr["rank"] = "same"
        dot.graph_attr["ratio"] = "compress"
        dot.graph_attr["margin"] = "0.1"

        leftovers = set([v for v in V if in_degree[v]])
        for x in leftovers:
            dot.node(
                x.__name__ + "\\n@" + repr(top.get_update_block_host_component(x)),
                shape="box",
            )

        for (x, y) in E:
            if x in leftovers and y in leftovers:
                dot.edge(
                    x.__name__ + "\\n@" + repr(top.get_update_block_host_component(x)),
                    y.__name__ + "\\n@" + repr(top.get_update_block_host_component(y)),
                )
        dot.render("/tmp/upblk-dag.gv", view=True)

        raise UpblkCyclicError(
            """
Update blocks have cyclic dependencies.
* Please consult update dependency graph for details."
    """
        )
